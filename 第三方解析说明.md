# ç¬¬ä¸‰æ–¹è§£æå®ç°è¯¦è§£

## ğŸ“‹ è§£ææ–¹å¼æ¦‚è¿°

ç³»ç»Ÿæä¾›ä¸¤ç§æ— æ°´å°è§†é¢‘è§£ææ–¹å¼:
1. **ç¬¬ä¸‰æ–¹è§£æ** (é»˜è®¤) - ä½¿ç”¨å…¬å…±CDNæœåŠ¡
2. **è‡ªå®šä¹‰è§£ææ¥å£** - ä½¿ç”¨è‡ªå»ºè§£ææœåŠ¡å™¨

---

## ğŸ” ç¬¬ä¸‰æ–¹è§£æçš„å®ç°åŸç†

### 1. è§£æåœ°å€æ¨¡æ¿

```
https://oscdn2.dyysy.com/MP4/{post_id}.mp4
```

**ä»£ç ä½ç½®**: `src/services/generation_handler.py` ç¬¬913è¡Œ

```python
# Use third-party parse (default)
watermark_free_url = f"https://oscdn2.dyysy.com/MP4/{post_id}.mp4"
debug_logger.log_info("Using third-party parse server")
```

### 2. å·¥ä½œæµç¨‹

```
1. è§†é¢‘ç”Ÿæˆå®Œæˆ 
   â†“
2. è·å– generation_id
   â†“
3. å‘å¸ƒåˆ°Soraå¹³å° (è°ƒç”¨ /project_y/post API)
   â†“
4. è·å– post_id (æ ¼å¼: s_xxxxx...)
   â†“
5. æ„é€ æ— æ°´å°URL: https://oscdn2.dyysy.com/MP4/{post_id}.mp4
   â†“
6. è½®è¯¢æ£€æŸ¥URLæ˜¯å¦è¿”å›200çŠ¶æ€ç 
   â†“
7. ä¸‹è½½å¹¶ç¼“å­˜åˆ°æœ¬åœ° (å¦‚æœå¯ç”¨ç¼“å­˜)
   â†“
8. è‡ªåŠ¨åˆ é™¤Soraå¹³å°ä¸Šçš„å‘å¸ƒå†…å®¹
```

### 3. æ ¸å¿ƒä»£ç å®ç°

**å‘å¸ƒè§†é¢‘è·å– post_id** (`src/services/sora_client.py` ç¬¬304-329è¡Œ):

```python
async def post_video_for_watermark_free(self, generation_id: str, prompt: str, token: str) -> str:
    """Post video to get watermark-free version

    Args:
        generation_id: The generation ID (e.g., gen_01k9btrqrnen792yvt703dp0tq)
        prompt: The original generation prompt
        token: Access token

    Returns:
        Post ID (e.g., s_690ce161c2488191a3476e9969911522)
    """
    json_data = {
        "attachments_to_create": [
            {
                "generation_id": generation_id,
                "kind": "sora"
            }
        ],
        "post_text": ""
    }

    # å‘å¸ƒè¯·æ±‚éœ€è¦æ·»åŠ  sentinel token
    result = await self._make_request("POST", "/project_y/post", token, json_data=json_data, add_sentinel_token=True)

    # è¿”å› post.id
    return result.get("post", {}).get("id", "")
```

**æ„é€ ç¬¬ä¸‰æ–¹è§£æURL** (`src/services/generation_handler.py` ç¬¬890-914è¡Œ):

```python
# 2) Resolve watermark-free URL
if parse_method == "custom":
    if not watermark_config.custom_parse_url or not watermark_config.custom_parse_token:
        raise Exception("Custom parse server URL or token not configured")
    if stream:
        yield self._format_stream_chunk(
            reasoning_content=f"Video published successfully. Post ID: {post_id}\nUsing custom parse server to get watermark-free URL...\n",
            extra={
                "wm": {
                    "stage": "parse",
                    "attempt": wm_attempt,
                    "can_cancel": wm_attempt >= 3,
                    "task_id": task_id,
                }
            }
        )
    watermark_free_url = await self.sora_client.get_watermark_free_url_custom(
        parse_url=watermark_config.custom_parse_url,
        parse_token=watermark_config.custom_parse_token,
        post_id=post_id,
        access_token=token
    )
else:
    # Use third-party parse (default)
    watermark_free_url = f"https://oscdn2.dyysy.com/MP4/{post_id}.mp4"
    debug_logger.log_info("Using third-party parse server")
```

**ç­‰å¾…æ–‡ä»¶å°±ç»ª** (`src/services/generation_handler.py` ç¬¬934-976è¡Œ):

```python
# 3) Wait for watermark-free file to become available (retry forever unless cancelled)
ready_checks = 0
while True:
    if cancel_event.is_set():
        break

    ready_checks += 1
    status_code = None
    last_err = None
    try:
        async with AsyncSession() as session:
            resp = await session.head(
                watermark_free_url,
                timeout=20,
                impersonate="chrome"
            )
            status_code = resp.status_code
    except Exception as e:
        last_err = str(e)

    if status_code == 200:
        break

    wm_attempt += 1
    if stream:
        hint = f"HTTP {status_code}" if status_code else (last_err or "unknown")
        yield self._format_stream_chunk(
            reasoning_content=f"Watermark-free file not ready ({hint}), waiting... (attempt {wm_attempt})\n",
            extra={
                "wm": {
                    "stage": "waiting",
                    "attempt": wm_attempt,
                    "can_cancel": wm_attempt >= 3,
                    "task_id": task_id,
                }
            }
        )

    await asyncio.sleep(10 + random.uniform(0, 0.5))
```

**åˆ é™¤å‘å¸ƒ** (`src/services/sora_client.py` ç¬¬331-396è¡Œ):

```python
async def delete_post(self, post_id: str, token: str) -> bool:
    """Delete a published post

    Args:
        post_id: The post ID (e.g., s_690ce161c2488191a3476e9969911522)
        token: Access token

    Returns:
        True if deletion was successful
    """
    proxy_url = await self.proxy_manager.get_proxy_url()

    headers = {
        "Authorization": f"Bearer {token}"
    }

    async with AsyncSession() as session:
        url = f"{self.base_url}/project_y/post/{post_id}"

        kwargs = {
            "headers": headers,
            "timeout": self.timeout,
            "impersonate": "chrome"
        }

        if proxy_url:
            kwargs["proxy"] = proxy_url

        # Log request
        debug_logger.log_request(
            method="DELETE",
            url=url,
            headers=headers,
            body=None,
            files=None,
            proxy=proxy_url
        )

        # Record start time
        start_time = time.time()

        # Make DELETE request
        response = await session.delete(url, **kwargs)

        # Calculate duration
        duration_ms = (time.time() - start_time) * 1000

        # Log response
        debug_logger.log_response(
            status_code=response.status_code,
            headers=dict(response.headers),
            body=response.text if response.text else "No content",
            duration_ms=duration_ms
        )

        # Check status (DELETE typically returns 204 No Content or 200 OK)
        if response.status_code not in [200, 204]:
            error_msg = f"Delete post failed: {response.status_code} - {response.text}"
            debug_logger.log_error(
                error_message=error_msg,
                status_code=response.status_code,
                response_text=response.text
            )
            raise Exception(error_msg)

        return True
```

---

## ğŸ“Š åŸŸåéªŒè¯è§„åˆ™

å‰ç«¯ä¼šéªŒè¯è§†é¢‘URLçš„åˆæ³•æ€§ (`static/js/generate.js` ç¬¬216è¡Œ):

```javascript
const domainOk = /(?:^https?:\/\/)?(?:videos\.openai\.com|oscdn\d*\.dyysy\.com)/i.test(s);
```

**æ”¯æŒçš„åŸŸå**:
- `videos.openai.com` (å®˜æ–¹åŸŸå)
- `oscdn.dyysy.com` (ç¬¬ä¸‰æ–¹CDN)
- `oscdn2.dyysy.com` (ç¬¬ä¸‰æ–¹CDNå¤‡ç”¨)
- `oscdn[ä»»æ„æ•°å­—].dyysy.com` (æ”¯æŒå¤šä¸ªCDNèŠ‚ç‚¹)

---

## âš™ï¸ é…ç½®æ–¹å¼

### å‰ç«¯é…ç½® (`static/manage.html` ç¬¬809è¡Œ)

```html
<select id="cfgParseMethod">
    <option value="third_party">ç¬¬ä¸‰æ–¹è§£æ</option>
    <option value="custom">è‡ªå®šä¹‰è§£ææ¥å£</option>
</select>
```

### åç«¯é…ç½® (`config/setting.toml` ç¬¬41è¡Œ)

```toml
[watermark_free]
parse_method = "third_party"
```

### æ•°æ®åº“é…ç½®

è¡¨å: `watermark_free_config`

å­—æ®µ:
- `watermark_free_enabled` (BOOLEAN) - æ˜¯å¦å¯ç”¨æ— æ°´å°æ¨¡å¼
- `parse_method` (TEXT) - è§£ææ–¹å¼: "third_party" æˆ– "custom"
- `custom_parse_url` (TEXT) - è‡ªå®šä¹‰è§£ææœåŠ¡å™¨åœ°å€
- `custom_parse_token` (TEXT) - è‡ªå®šä¹‰è§£ææœåŠ¡å™¨å¯†é’¥

---

## ğŸ”„ è‡ªå®šä¹‰è§£ææ¥å£å¯¹æ¯”

å¦‚æœé€‰æ‹©**è‡ªå®šä¹‰è§£ææ¥å£**,ç³»ç»Ÿä¼šè°ƒç”¨è‡ªå»ºæœåŠ¡å™¨ (`src/services/sora_client.py` ç¬¬398-490è¡Œ):

```python
async def get_watermark_free_url_custom(self, parse_url: str, parse_token: str, post_id: str, access_token: str) -> str:
    """Get watermark-free video URL from custom parse server

    Args:
        parse_url: Custom parse server URL (e.g., http://example.com)
        parse_token: Access token for custom parse server
        post_id: Post ID to parse (e.g., s_690c0f574c3881918c3bc5b682a7e9fd)
        access_token: Sora access token to use for fetching the download link (overrides server-side env)

    Returns:
        Download link from custom parse server

    Raises:
        Exception: If parse fails or token is invalid
    """
    proxy_url = await self.proxy_manager.get_proxy_url()

    # Construct the share URL
    share_url = f"https://sora.chatgpt.com/p/{post_id}"

    # Prepare request
    json_data = {
        "url": share_url,
        "token": parse_token,
        "access_token": access_token
    }

    kwargs = {
        "json": json_data,
        "timeout": 30,
        "impersonate": "chrome"
    }

    if proxy_url:
        kwargs["proxy"] = proxy_url

    try:
        async with AsyncSession() as session:
            # Record start time
            start_time = time.time()

            # Make POST request to custom parse server
            response = await session.post(f"{parse_url}/get-sora-link", **kwargs)

            # Calculate duration
            duration_ms = (time.time() - start_time) * 1000

            # Log response
            debug_logger.log_response(
                status_code=response.status_code,
                headers=dict(response.headers),
                body=response.text if response.text else "No content",
                duration_ms=duration_ms
            )

            # Check status
            if response.status_code != 200:
                error_msg = f"Custom parse failed: {response.status_code} - {response.text}"
                debug_logger.log_error(
                    error_message=error_msg,
                    status_code=response.status_code,
                    response_text=response.text
                )
                raise Exception(error_msg)

            # Parse response
            result = response.json()

            # Check for error in response
            if "error" in result:
                error_msg = f"Custom parse error: {result['error']}"
                debug_logger.log_error(
                    error_message=error_msg,
                    status_code=401,
                    response_text=str(result)
                )
                raise Exception(error_msg)

            # Extract download link
            download_link = result.get("download_link")
            if not download_link:
                raise Exception("No download_link in custom parse response")

            debug_logger.log_info(f"Custom parse successful: {download_link}")
            return download_link

    except Exception as e:
        debug_logger.log_error(
            error_message=f"Custom parse request failed: {str(e)}",
            status_code=500,
            response_text=str(e)
        )
        raise
```

**è‡ªå®šä¹‰è§£æéœ€è¦é…ç½®**:
- è§£ææœåŠ¡å™¨åœ°å€ (å¦‚: `http://example.com`)
- è®¿é—®å¯†é’¥ (Token)

**å‚è€ƒé¡¹ç›®**: [sora-downloader](https://github.com/tibbar213/sora-downloader)

---

## ğŸ“ é…ç½®æ–‡ä»¶ä½ç½®

| æ–‡ä»¶ | è·¯å¾„ | è¯´æ˜ |
|------|------|------|
| é…ç½®æ–‡ä»¶ | `config/setting.toml` | é»˜è®¤è§£ææ–¹å¼é…ç½® |
| æ•°æ®åº“ | `watermark_free_config` è¡¨ | è¿è¡Œæ—¶é…ç½®å­˜å‚¨ |
| å‰ç«¯ç•Œé¢ | `static/manage.html` | ç®¡ç†ç•Œé¢é…ç½® |
| åç«¯é€»è¾‘ | `src/services/generation_handler.py` | è§£æå®ç°é€»è¾‘ |
| APIå®¢æˆ·ç«¯ | `src/services/sora_client.py` | Sora APIè°ƒç”¨ |

---

## ğŸ’¾ å¦‚ä½•ä¸‹è½½è§†é¢‘åˆ°æœ¬åœ°

### æ–¹æ³•1: ä½¿ç”¨ç³»ç»Ÿè‡ªåŠ¨ç¼“å­˜

å¦‚æœå¯ç”¨äº†ç¼“å­˜åŠŸèƒ½,ç³»ç»Ÿä¼šè‡ªåŠ¨ä¸‹è½½è§†é¢‘åˆ°æœ¬åœ° (`src/services/generation_handler.py` ç¬¬994-1032è¡Œ):

```python
# 4) Cache watermark-free video (if cache enabled)
if config.cache_enabled:
    try:
        cached_filename = await self._download_with_retry(watermark_free_url, "video")
        local_url = f"{self._get_base_url()}/tmp/{cached_filename}"
        if stream:
            yield self._format_stream_chunk(
                reasoning_content="Watermark-free video cached successfully. Preparing final response...\n"
            )

        # Delete the published post after caching (best-effort)
        try:
            debug_logger.log_info(f"Deleting published post: {post_id}")
            await self.sora_client.delete_post(post_id, token)
            debug_logger.log_info(f"Published post deleted successfully: {post_id}")
        except Exception as delete_error:
            debug_logger.log_error(
                error_message=f"Failed to delete published post {post_id}: {str(delete_error)}",
                status_code=500,
                response_text=str(delete_error)
            )
    except Exception as cache_error:
        # Fallback to watermark-free URL if caching fails
        local_url = watermark_free_url
        if stream:
            yield self._format_stream_chunk(
                reasoning_content=(
                    f"Warning: Failed to cache file - {str(cache_error)}\n"
                    "Using original watermark-free URL instead...\n"
                )
            )
else:
    # Cache disabled: use watermark-free URL directly
    local_url = watermark_free_url
    if stream:
        yield self._format_stream_chunk(
            reasoning_content="Cache is disabled. Using watermark-free URL directly...\n"
        )
```

**ç¼“å­˜æ–‡ä»¶ä½ç½®**: `tmp/` ç›®å½•ä¸‹

### æ–¹æ³•2: æ‰‹åŠ¨ä¸‹è½½

#### ä½¿ç”¨å‘½ä»¤è¡Œ (curl)

```bash
# æ›¿æ¢ {post_id} ä¸ºå®é™…çš„ post_id
curl -o video.mp4 "https://oscdn2.dyysy.com/MP4/{post_id}.mp4"
```

#### ä½¿ç”¨å‘½ä»¤è¡Œ (wget)

```bash
# æ›¿æ¢ {post_id} ä¸ºå®é™…çš„ post_id
wget -O video.mp4 "https://oscdn2.dyysy.com/MP4/{post_id}.mp4"
```

#### ä½¿ç”¨ Python

```python
import requests

post_id = "s_69485aa1b968819195130fd5ab9a393e"
url = f"https://oscdn2.dyysy.com/MP4/{post_id}.mp4"

response = requests.get(url, stream=True)
with open("video.mp4", "wb") as f:
    for chunk in response.iter_content(chunk_size=8192):
        f.write(chunk)

print("ä¸‹è½½å®Œæˆ!")
```

#### ä½¿ç”¨æµè§ˆå™¨

ç›´æ¥åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€ä»¥ä¸‹åœ°å€:
```
https://oscdn2.dyysy.com/MP4/{post_id}.mp4
```

æµè§ˆå™¨ä¼šè‡ªåŠ¨å¼€å§‹ä¸‹è½½è§†é¢‘ã€‚

### æ–¹æ³•3: ä½¿ç”¨ç³»ç»Ÿçš„ä¸‹è½½é‡è¯•æœºåˆ¶

ç³»ç»Ÿå†…ç½®äº†å¸¦é‡è¯•çš„ä¸‹è½½æ–¹æ³• (`src/services/generation_handler.py`):

```python
async def _download_with_retry(self, url: str, file_type: str, max_retries: int = 3) -> str:
    """Download file with retry mechanism
    
    Args:
        url: File URL to download
        file_type: Type of file ("image" or "video")
        max_retries: Maximum number of retry attempts
        
    Returns:
        Cached filename
    """
    for attempt in range(max_retries):
        try:
            return await self.file_cache.download_and_cache(url, file_type)
        except Exception as e:
            if attempt < max_retries - 1:
                wait_time = 2 ** attempt  # Exponential backoff
                debug_logger.log_info(f"Download attempt {attempt + 1} failed, retrying in {wait_time}s...")
                await asyncio.sleep(wait_time)
            else:
                raise e
```

---

## ğŸ¯ å®é™…ç¤ºä¾‹: ä½ çš„URLè§£æ

### åŸå§‹åˆ†äº«é“¾æ¥

```
https://sora.chatgpt.com/p/s_69485aa1b968819195130fd5ab9a393e?psh=HXVzZXItcXRTZk5DR1h6OVRDYU95NjF1MVB3bUIx.ZjQBGbKlltBu
```

### URLç»“æ„åˆ†æ

| éƒ¨åˆ† | å€¼ | è¯´æ˜ |
|------|-----|------|
| åŸºç¡€URL | `https://sora.chatgpt.com/p/` | Soraåˆ†äº«é¡µé¢åŸºç¡€è·¯å¾„ |
| **Post ID** | `s_69485aa1b968819195130fd5ab9a393e` | è§†é¢‘å‘å¸ƒID (32ä½åå…­è¿›åˆ¶) |
| åˆ†äº«å‚æ•° | `?psh=HXVzZXItcXRTZk5DR1h6OVRDYU95NjF1MVB3bUIx.ZjQBGbKlltBu` | åˆ†äº«ä»¤ç‰Œ (å¯é€‰) |

### æå–çš„ Post ID

```
s_69485aa1b968819195130fd5ab9a393e
```

### å¯¹åº”çš„ç¬¬ä¸‰æ–¹è§£æåœ°å€

```
https://oscdn2.dyysy.com/MP4/s_69485aa1b968819195130fd5ab9a393e.mp4
```

### ä¸‹è½½å‘½ä»¤

```bash
# ä½¿ç”¨ curl
curl -o my_video.mp4 "https://oscdn2.dyysy.com/MP4/s_69485aa1b968819195130fd5ab9a393e.mp4"

# ä½¿ç”¨ wget
wget -O my_video.mp4 "https://oscdn2.dyysy.com/MP4/s_69485aa1b968819195130fd5ab9a393e.mp4"
```

### Python ä¸‹è½½è„šæœ¬

```python
import requests

# ä½ çš„ post_id
post_id = "s_69485aa1b968819195130fd5ab9a393e"

# æ„é€ ä¸‹è½½åœ°å€
url = f"https://oscdn2.dyysy.com/MP4/{post_id}.mp4"

# ä¸‹è½½è§†é¢‘
print(f"å¼€å§‹ä¸‹è½½: {url}")
response = requests.get(url, stream=True)

if response.status_code == 200:
    with open("sora_video.mp4", "wb") as f:
        for chunk in response.iter_content(chunk_size=1024*1024):  # 1MB chunks
            if chunk:
                f.write(chunk)
    print("âœ… ä¸‹è½½å®Œæˆ: sora_video.mp4")
else:
    print(f"âŒ ä¸‹è½½å¤±è´¥: HTTP {response.status_code}")
```

---

## ğŸ“Œ Post ID æ ¼å¼è¯´æ˜

- **å‰ç¼€**: `s_` (è¡¨ç¤º Sora åˆ†äº«)
- **é•¿åº¦**: 32ä½åå…­è¿›åˆ¶å­—ç¬¦
- **æ ¼å¼**: `s_[32ä½hex]`
- **ç¤ºä¾‹**: 
  - `s_69485aa1b968819195130fd5ab9a393e`
  - `s_690ce161c2488191a3476e9969911522`

---

## ğŸ¯ æ€»ç»“

### ç¬¬ä¸‰æ–¹è§£æçš„æ ¸å¿ƒä¼˜åŠ¿

âœ… **è§£æåœ°å€**: `https://oscdn2.dyysy.com/MP4/{post_id}.mp4`  
âœ… **æ— éœ€é…ç½®**: å¼€ç®±å³ç”¨,ä¸éœ€è¦é¢å¤–çš„æœåŠ¡å™¨æˆ–å¯†é’¥  
âœ… **å·¥ä½œåŸç†**: åˆ©ç”¨ç¬¬ä¸‰æ–¹CDNæœåŠ¡ç›´æ¥è®¿é—®Soraå‘å¸ƒçš„æ— æ°´å°è§†é¢‘  
âœ… **ä¼˜ç‚¹**: ç®€å•ã€å¿«é€Ÿã€å…è´¹  
âš ï¸ **ç¼ºç‚¹**: ä¾èµ–ç¬¬ä¸‰æ–¹æœåŠ¡çš„ç¨³å®šæ€§  

### ä½¿ç”¨å»ºè®®

1. **æ—¥å¸¸ä½¿ç”¨**: ç¬¬ä¸‰æ–¹è§£æå·²ç»è¶³å¤Ÿç¨³å®šå¿«é€Ÿ
2. **é«˜å¯ç”¨éœ€æ±‚**: å¯ä»¥è€ƒè™‘éƒ¨ç½²è‡ªå®šä¹‰è§£ææ¥å£
3. **æ‰¹é‡ä¸‹è½½**: å»ºè®®å¯ç”¨ç³»ç»Ÿç¼“å­˜åŠŸèƒ½
4. **ç½‘ç»œé—®é¢˜**: å¦‚é‡404é”™è¯¯,ç­‰å¾…10-30ç§’åé‡è¯•

---

## ğŸ“š ç›¸å…³èµ„æº

- **è‡ªå®šä¹‰è§£ææœåŠ¡å™¨**: https://github.com/tibbar213/sora-downloader
- **Soraå®˜æ–¹å¹³å°**: https://sora.chatgpt.com
- **é¡¹ç›®ä»“åº“**: https://github.com/TheSmallHanCat/sora2api
